# Todo app files from chapter 5

<file_start>todo_app/tests/application/conftest.py</file_start>
# todo_app/tests/application/conftest.py
"""Test fixtures and utilities for application layer tests."""

from dataclasses import dataclass
from typing import Sequence
from uuid import UUID

from todo_app.application.ports.notifications import (
    NotificationPort,
)
from todo_app.application.repositories.project_repository import (
    ProjectRepository,
)
from todo_app.application.repositories.task_repository import (
    TaskRepository,
)
from todo_app.domain.entities.project import Project
from todo_app.domain.entities.task import Task
from todo_app.domain.exceptions import (
    TaskNotFoundError,
    ProjectNotFoundError,
)
from todo_app.domain.value_objects import TaskStatus


@dataclass
class InMemoryTaskRepository(TaskRepository):
    """In-memory implementation of TaskRepository for testing."""

    _tasks: dict[UUID, Task]

    def __init__(self) -> None:
        self._tasks = {}

    def get(self, task_id: UUID) -> Task:
        if task := self._tasks.get(task_id):
            return task
        raise TaskNotFoundError(task_id)

    def save(self, task: Task) -> None:
        self._tasks[task.id] = task

    def delete(self, task_id: UUID) -> None:
        self._tasks.pop(task_id, None)

    def find_by_project(self, project_id: UUID) -> Sequence[Task]:
        return [
            task
            for task in self._tasks.values()
            if task.project_id == project_id
        ]

    def get_active_tasks(self) -> Sequence[Task]:
        return [
            task
            for task in self._tasks.values()
            if task.status != TaskStatus.DONE
        ]


@dataclass
class InMemoryProjectRepository(ProjectRepository):
    """In-memory implementation of ProjectRepository for testing."""

    _projects: dict[UUID, Project]

    def __init__(self) -> None:
        self._projects = {}

    def get(self, project_id: UUID) -> Project:
        if project := self._projects.get(project_id):
            return project
        raise ProjectNotFoundError(project_id)

    def save(self, project: Project) -> None:
        self._projects[project.id] = project

    def delete(self, project_id: UUID) -> None:
        self._projects.pop(project_id, None)


@dataclass
class NotificationRecorder(NotificationPort):
    """Records notifications for testing verification."""

    completed_tasks: list[UUID]
    high_priority_tasks: list[UUID]
    deadline_warnings: list[tuple[UUID, int]]

    def __init__(self) -> None:
        self.completed_tasks = []
        self.high_priority_tasks = []
        self.deadline_warnings = []

    def notify_task_completed(self, task_id: UUID) -> None:
        self.completed_tasks.append(task_id)

    def notify_task_high_priority(self, task_id: UUID) -> None:
        self.high_priority_tasks.append(task_id)

    def notify_task_deadline_approaching(
        self, task_id: UUID, days_remaining: int
    ) -> None:
        self.deadline_warnings.append((task_id, days_remaining))

<file_end>todo_app/tests/application/conftest.py</file_end>

<file_start>todo_app/tests/application/.pytest_cache/CACHEDIR.TAG</file_start>
Signature: 8a477f597d28d172789f06886806bc55
# This file is a cache directory tag created by pytest.
# For information about cache directory tags, see:
#	https://bford.info/cachedir/spec.html

<file_end>todo_app/tests/application/.pytest_cache/CACHEDIR.TAG</file_end>

<file_start>todo_app/tests/application/.pytest_cache/README.md</file_start>
# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.

<file_end>todo_app/tests/application/.pytest_cache/README.md</file_end>

<file_start>todo_app/tests/application/.pytest_cache/.gitignore</file_start>
# Created by pytest automatically.
*

<file_end>todo_app/tests/application/.pytest_cache/.gitignore</file_end>

<file_start>todo_app/tests/application/.pytest_cache/v/cache/nodeids</file_start>
[
  "test_project_use_cases.py::test_complete_project_fails_with_malformed_project_id",
  "test_project_use_cases.py::test_complete_project_with_incomplete_tasks",
  "test_task_use_cases.py::test_create_task_with_malformed_project_id",
  "test_task_use_cases.py::test_create_task_with_project"
]
<file_end>todo_app/tests/application/.pytest_cache/v/cache/nodeids</file_end>

<file_start>todo_app/tests/application/.pytest_cache/v/cache/lastfailed</file_start>
{
  "test_project_use_cases.py::test_complete_project_with_incomplete_tasks": true,
  "test_task_use_cases.py::test_create_task_with_project": true,
  "test_task_use_cases.py::test_create_task_with_malformed_project_id": true
}
<file_end>todo_app/tests/application/.pytest_cache/v/cache/lastfailed</file_end>

<file_start>todo_app/tests/application/.pytest_cache/v/cache/stepwise</file_start>
[]
<file_end>todo_app/tests/application/.pytest_cache/v/cache/stepwise</file_end>

<file_start>todo_app/tests/application/test_dtos.py</file_start>
# todo_app/tests/application/test_dtos.py
"""Tests for DTO validation logic."""

from datetime import datetime, timedelta

import pytest

from todo_app.application.dtos.project_dtos import (
    CompleteProjectRequest,
    CreateProjectRequest,
)
from todo_app.application.dtos.task_dtos import (
    CompleteTaskRequest,
    CreateTaskRequest,
    SetTaskPriorityRequest,
)


class TestCompleteTaskRequest:
    def test_valid_request(self):
        """Test creating request with valid data."""
        request = CompleteTaskRequest(
            task_id="123e4567-e89b-12d3-a456-426614174000",
            completion_notes="Task completed successfully"
        )
        assert request.task_id == "123e4567-e89b-12d3-a456-426614174000"
        assert request.completion_notes == "Task completed successfully"

    def test_empty_task_id(self):
        """Test validation of empty task_id."""
        with pytest.raises(ValueError, match="Task ID is required"):
            CompleteTaskRequest(task_id="   ", completion_notes="Done")

    def test_completion_notes_too_long(self):
        """Test validation of completion notes length."""
        with pytest.raises(ValueError, match="Completion notes cannot exceed 1000 characters"):
            CompleteTaskRequest(
                task_id="123e4567-e89b-12d3-a456-426614174000",
                completion_notes="x" * 1001
            )


class TestCreateTaskRequest:
    def test_valid_request(self):
        """Test creating request with valid data."""
        request = CreateTaskRequest(
            title="Test Task",
            description="Test Description",
            due_date=(datetime.now() + timedelta(days=1)).isoformat(),
            priority="HIGH",
            project_id="123e4567-e89b-12d3-a456-426614174000"
        )
        assert request.title == "Test Task"
        assert request.description == "Test Description"

    def test_empty_title(self):
        """Test validation of empty title."""
        with pytest.raises(ValueError, match="Title is required"):
            CreateTaskRequest(title="   ", description="Test")

    def test_title_too_long(self):
        """Test validation of title length."""
        with pytest.raises(ValueError, match="Title cannot exceed 200 characters"):
            CreateTaskRequest(title="x" * 201, description="Test")

    def test_description_too_long(self):
        """Test validation of description length."""
        with pytest.raises(ValueError, match="Description cannot exceed 2000 characters"):
            CreateTaskRequest(title="Test", description="x" * 2001)


class TestSetTaskPriorityRequest:
    def test_valid_request(self):
        """Test creating request with valid data."""
        request = SetTaskPriorityRequest(
            task_id="123e4567-e89b-12d3-a456-426614174000",
            priority="HIGH"
        )
        assert request.task_id == "123e4567-e89b-12d3-a456-426614174000"
        assert request.priority == "HIGH"

    def test_empty_task_id(self):
        """Test validation of empty task_id."""
        with pytest.raises(ValueError, match="Task ID is required"):
            SetTaskPriorityRequest(task_id="   ", priority="HIGH")

    def test_invalid_priority(self):
        """Test validation of invalid priority."""
        with pytest.raises(ValueError, match="Priority must be one of:"):
            SetTaskPriorityRequest(
                task_id="123e4567-e89b-12d3-a456-426614174000",
                priority="INVALID"
            )

    def test_empty_priority(self):
        """Test validation of empty priority."""
        with pytest.raises(ValueError, match="Priority must be one of:"):
            SetTaskPriorityRequest(
                task_id="123e4567-e89b-12d3-a456-426614174000",
                priority="   "
            )


class TestCreateProjectRequest:
    def test_valid_request(self):
        """Test creating request with valid data."""
        request = CreateProjectRequest(
            name="Test Project",
            description="Test Description"
        )
        assert request.name == "Test Project"
        assert request.description == "Test Description"

    def test_empty_name(self):
        """Test validation of empty name."""
        with pytest.raises(ValueError, match="Project name is required"):
            CreateProjectRequest(name="   ", description="Test")

    def test_name_too_long(self):
        """Test validation of name length."""
        with pytest.raises(ValueError, match="Project name cannot exceed 100 characters"):
            CreateProjectRequest(name="x" * 101, description="Test")

    def test_description_too_long(self):
        """Test validation of description length."""
        with pytest.raises(ValueError, match="Description cannot exceed 2000 characters"):
            CreateProjectRequest(name="Test", description="x" * 2001)


class TestCompleteProjectRequest:
    def test_valid_request(self):
        """Test creating request with valid data."""
        request = CompleteProjectRequest(
            project_id="123e4567-e89b-12d3-a456-426614174000",
            completion_notes="Project completed successfully"
        )
        assert request.project_id == "123e4567-e89b-12d3-a456-426614174000"
        assert request.completion_notes == "Project completed successfully"

    def test_empty_project_id(self):
        """Test validation of empty project_id."""
        with pytest.raises(ValueError, match="Project ID is required"):
            CompleteProjectRequest(project_id="   ", completion_notes="Done")

    def test_completion_notes_too_long(self):
        """Test validation of completion notes length."""
        with pytest.raises(ValueError, match="Completion notes cannot exceed 1000 characters"):
            CompleteProjectRequest(
                project_id="123e4567-e89b-12d3-a456-426614174000",
                completion_notes="x" * 1001
            )


def test_execution_params_conversion():
    """Test conversion of DTOs to execution parameters."""
    # Test CreateTaskRequest conversion
    task_request = CreateTaskRequest(
        title="Test Task",
        description="Test Description",
        due_date=(datetime.now() + timedelta(days=1)).isoformat(),
        priority="HIGH",
        project_id="123e4567-e89b-12d3-a456-426614174000"
    )
    task_params = task_request.to_execution_params()
    assert task_params["title"] == "Test Task"
    assert task_params["description"] == "Test Description"
    assert "deadline" in task_params
    assert "priority" in task_params
    assert "project_id" in task_params

    # Test CreateProjectRequest conversion
    project_request = CreateProjectRequest(
        name="Test Project",
        description="Test Description"
    )
    project_params = project_request.to_execution_params()
    assert project_params["name"] == "Test Project"
    assert project_params["description"] == "Test Description"
<file_end>todo_app/tests/application/test_dtos.py</file_end>

<file_start>todo_app/tests/application/test_project_use_cases.py</file_start>
# todo_app/tests/application/test_project_use_cases.py
"""Tests for project-related use cases."""

from uuid import uuid4

import pytest

from todo_app.application.common.result import ErrorCode
from todo_app.application.dtos.project_dtos import (
    CreateProjectRequest,
    CompleteProjectRequest,
)
from todo_app.application.use_cases.project_use_cases import (
    CreateProjectUseCase,
    CompleteProjectUseCase,
)
from todo_app.domain.entities.project import Project
from todo_app.domain.entities.task import Task
from todo_app.domain.exceptions import (
    BusinessRuleViolation,
    ValidationError,
)
from todo_app.domain.value_objects import (
    ProjectStatus,
    TaskStatus,
)
from todo_app.application.conftest import (
    InMemoryProjectRepository,
    InMemoryTaskRepository,
    NotificationRecorder,
)


def test_create_project():
    """Test creating a project with basic information."""
    # Arrange
    repo = InMemoryProjectRepository()
    use_case = CreateProjectUseCase(repo)

    request = CreateProjectRequest(
        name="Test Project", description="Test Description"
    )

    # Act
    result = use_case.execute(request)

    # Assert
    assert result.is_success
    assert result.value.name == "Test Project"
    assert result.value.description == "Test Description"
    assert result.value.status == ProjectStatus.ACTIVE.value


def test_complete_project_without_tasks():
    """Test completing a project that has no tasks."""
    # Arrange
    project_repo = InMemoryProjectRepository()
    task_repo = InMemoryTaskRepository()
    notify_port = NotificationRecorder()
    use_case = CompleteProjectUseCase(project_repo, task_repo, notify_port)

    # Create and save a project
    project = Project(name="Test Project")
    project_repo.save(project)

    request = CompleteProjectRequest(
        project_id=str(project.id), completion_notes="All done!"
    )

    # Act
    result = use_case.execute(request)

    # Assert
    assert result.is_success
    assert result.value.status == ProjectStatus.COMPLETED.value
    assert result.value.completion_notes == "All done!"
    assert result.value.task_count == 0


def test_complete_project_with_incomplete_tasks():
    """Test completing a project that has incomplete tasks.  All tasks should be marked as done."""
    # Arrange
    project_repo = InMemoryProjectRepository()
    task_repo = InMemoryTaskRepository()
    notify_port = NotificationRecorder()
    use_case = CompleteProjectUseCase(project_repo, task_repo, notify_port)

    # Create project with task
    project = Project(name="Test Project")
    task = Task(title="Test Task", description="Test")
    project.add_task(task)
    project_repo.save(project)

    request = CompleteProjectRequest(
        project_id=str(project.id), completion_notes="Done!"
    )

    # Act
    result = use_case.execute(request)

    # Assert
    assert result.is_success
    assert task.status == TaskStatus.DONE


def test_complete_project_with_completed_tasks():
    """Test completing a project where all tasks are done."""
    # Arrange
    project_repo = InMemoryProjectRepository()
    task_repo = InMemoryTaskRepository()
    notify_port = NotificationRecorder()
    use_case = CompleteProjectUseCase(project_repo, task_repo, notify_port)

    # Create project with completed task
    project = Project(name="Test Project")
    task = Task(title="Test Task", description="Test")
    task.complete()  # Complete the task
    project.add_task(task)
    project_repo.save(project)

    request = CompleteProjectRequest(
        project_id=str(project.id), completion_notes="All done!"
    )

    # Act
    result = use_case.execute(request)

    # Assert
    assert result.is_success
    assert result.value.status == ProjectStatus.COMPLETED.value
    assert result.value.task_count == 1


def test_complete_nonexistent_project():
    """Test completing a project that doesn't exist."""
    # Arrange
    project_repo = InMemoryProjectRepository()
    task_repo = InMemoryTaskRepository()
    notify_port = NotificationRecorder()
    use_case = CompleteProjectUseCase(project_repo, task_repo, notify_port)

    request = CompleteProjectRequest(
        project_id=str(uuid4()), completion_notes="Done!"
    )

    # Act
    result = use_case.execute(request)

    # Assert
    assert not result.is_success
    assert result.error.code.value == "NOT_FOUND"


def test_create_project_handles_validation_error():
    """Test handling of ValidationError during project creation."""

    class ValidationErrorProjectRepository(InMemoryProjectRepository):
        def save(self, project):
            raise ValidationError("Invalid project data")

    repo = ValidationErrorProjectRepository()
    use_case = CreateProjectUseCase(repo)
    request = CreateProjectRequest(
        name="Test Project", description="Test Description"
    )

    result = use_case.execute(request)

    assert not result.is_success
    assert result.error.code == ErrorCode.VALIDATION_ERROR
    assert "Invalid project data" in result.error.message


def test_create_project_handles_business_rule_violation():
    """Test handling of BusinessRuleViolation during project creation."""

    class BusinessRuleProjectRepository(InMemoryProjectRepository):
        def save(self, project):
            raise BusinessRuleViolation("Project limit exceeded")

    repo = BusinessRuleProjectRepository()
    use_case = CreateProjectUseCase(repo)
    request = CreateProjectRequest(
        name="Test Project", description="Test Description"
    )

    result = use_case.execute(request)

    assert not result.is_success
    assert result.error.code == ErrorCode.BUSINESS_RULE_VIOLATION
    assert "Project limit exceeded" in result.error.message


def test_complete_project_handles_validation_error():
    """Test handling of ValidationError during project completion."""
    project = Project(name="Test Project")
    task = Task(title="Test Task", description="Test")
    project.add_task(task)

    class ValidationErrorProjectRepository(InMemoryProjectRepository):
        def save(self, project):
            raise ValidationError("Invalid completion state")

    project_repo = ValidationErrorProjectRepository()
    project_repo._projects[project.id] = project  # Add project directly
    task_repo = InMemoryTaskRepository()
    notifications = NotificationRecorder()

    use_case = CompleteProjectUseCase(project_repo, task_repo, notifications)
    request = CompleteProjectRequest(
        project_id=str(project.id), completion_notes="Done!"
    )

    result = use_case.execute(request)

    assert not result.is_success
    assert result.error.code == ErrorCode.VALIDATION_ERROR
    assert "Invalid completion state" in result.error.message
    assert not notifications.completed_tasks


def test_complete_project_fails_with_malformed_project_id():
    """Test handling of nonexistent project ID during task creation."""
    project_repo = InMemoryProjectRepository()

    # Test that this raised ValueError
    with pytest.raises(ValueError, match="Invalid project ID format"):
        _ = CompleteProjectRequest(
            project_id="malformed project id",
        )


def test_complete_project_handles_business_rule_violation():
    """Test handling of BusinessRuleViolation during project completion."""
    project = Project(name="Test Project")
    task = Task(title="Test Task", description="Test")
    project.add_task(task)

    class BusinessRuleProjectRepository(InMemoryProjectRepository):
        def save(self, project):
            raise BusinessRuleViolation(
                "Cannot complete project in current state"
            )

    project_repo = BusinessRuleProjectRepository()
    project_repo._projects[project.id] = project  # Add project directly
    task_repo = InMemoryTaskRepository()
    notifications = NotificationRecorder()

    use_case = CompleteProjectUseCase(project_repo, task_repo, notifications)
    request = CompleteProjectRequest(
        project_id=str(project.id), completion_notes="Done!"
    )

    result = use_case.execute(request)

    assert not result.is_success
    assert result.error.code == ErrorCode.BUSINESS_RULE_VIOLATION
    assert "Cannot complete project in current state" in result.error.message
    assert not notifications.completed_tasks


def test_complete_project_handles_validation_error_from_task():
    """Test handling of ValidationError from task operations during project completion."""
    project = Project(name="Test Project")
    task = Task(title="Test Task", description="Test")
    project.add_task(task)

    class ValidationErrorTaskRepository(InMemoryTaskRepository):
        def save(self, task):
            raise ValidationError("Invalid task completion state")

    project_repo = InMemoryProjectRepository()
    project_repo._projects[project.id] = project  # Add project directly
    task_repo = ValidationErrorTaskRepository()
    notifications = NotificationRecorder()

    use_case = CompleteProjectUseCase(project_repo, task_repo, notifications)
    request = CompleteProjectRequest(
        project_id=str(project.id), completion_notes="Done!"
    )

    result = use_case.execute(request)

    assert not result.is_success
    assert result.error.code == ErrorCode.VALIDATION_ERROR
    assert "Invalid task completion state" in result.error.message
    assert not notifications.completed_tasks


def test_complete_project_rolls_back_on_validation_error():
    """Test that project and task states are rolled back on ValidationError."""
    # Set up project with tasks
    project = Project(name="Test Project")
    task1 = Task(title="Task 1", description="Test")
    task2 = Task(title="Task 2", description="Test")
    project.add_task(task1)
    project.add_task(task2)

    # Repository that fails on project save but allows task saves
    class FailingProjectRepository(InMemoryProjectRepository):
        def save(self, project):
            if project.status == ProjectStatus.COMPLETED:
                raise ValidationError("Cannot complete project")
            super().save(project)

    project_repo = FailingProjectRepository()
    task_repo = InMemoryTaskRepository()
    notifications = NotificationRecorder()

    # Save initial state
    project_repo.save(project)
    task_repo.save(task1)
    task_repo.save(task2)

    use_case = CompleteProjectUseCase(project_repo, task_repo, notifications)
    request = CompleteProjectRequest(
        project_id=str(project.id), completion_notes="Done!"
    )

    # Execute use case (should fail)
    result = use_case.execute(request)

    # Verify failure
    assert not result.is_success
    assert result.error.code == ErrorCode.VALIDATION_ERROR

    # Verify project state was rolled back
    saved_project = project_repo.get(project.id)
    assert saved_project.status == ProjectStatus.ACTIVE

    # Verify task states were rolled back
    for task in [task1, task2]:
        saved_task = task_repo.get(task.id)
        assert saved_task.status == TaskStatus.TODO
        assert saved_task.completed_at is None
        assert saved_task.completion_notes is None


def test_complete_project_rolls_back_on_business_rule_violation():
    """Test that project and task states are rolled back on BusinessRuleViolation."""
    # Set up project with tasks
    project = Project(name="Test Project")
    task1 = Task(title="Task 1", description="Test")
    task2 = Task(title="Task 2", description="Test")
    project.add_task(task1)
    project.add_task(task2)

    # Repository that fails on last task save
    class FailingTaskRepository(InMemoryTaskRepository):
        def save(self, task):
            if (
                task.status == TaskStatus.DONE and task.title == "Task 2"
            ):  # Fail on second task
                raise BusinessRuleViolation("Task limit reached")
            super().save(task)

    project_repo = InMemoryProjectRepository()
    task_repo = FailingTaskRepository()
    notifications = NotificationRecorder()

    # Save initial state
    project_repo.save(project)
    task_repo.save(task1)
    task_repo.save(task2)

    use_case = CompleteProjectUseCase(project_repo, task_repo, notifications)
    request = CompleteProjectRequest(
        project_id=str(project.id), completion_notes="Done!"
    )

    # Execute use case (should fail)
    result = use_case.execute(request)

    # Verify failure
    assert not result.is_success
    assert result.error.code == ErrorCode.BUSINESS_RULE_VIOLATION

    # Verify project state was rolled back
    saved_project = project_repo.get(project.id)
    assert saved_project.status == ProjectStatus.ACTIVE

    # Verify all task states were rolled back
    for task in [task1, task2]:
        saved_task = task_repo.get(task.id)
        assert saved_task.status == TaskStatus.TODO
        assert saved_task.completed_at is None
        assert saved_task.completion_notes is None

    # Verify no notifications were kept
    assert not notifications.completed_tasks

<file_end>todo_app/tests/application/test_project_use_cases.py</file_end>

<file_start>todo_app/tests/application/test_deadline_use_case.py</file_start>
from datetime import datetime, timedelta
from uuid import UUID

from freezegun import freeze_time

from todo_app.application.common.result import ErrorCode
from todo_app.application.use_cases.deadline_use_cases import (
    CheckDeadlinesUseCase,
)
from todo_app.domain.entities.task import Task
from todo_app.domain.exceptions import (
    BusinessRuleViolation,
    ValidationError,
    TaskNotFoundError,
)
from todo_app.domain.value_objects import Deadline
from todo_app.application.conftest import (
    InMemoryTaskRepository,
    NotificationRecorder,
)


def test_check_deadlines_empty_repository():
    """Test checking deadlines with no tasks."""
    repo = InMemoryTaskRepository()
    notifications = NotificationRecorder()
    use_case = CheckDeadlinesUseCase(repo, notifications)

    result = use_case.execute()

    assert result.is_success
    assert result.value["notifications_sent"] == 0
    assert not notifications.deadline_warnings


@freeze_time("2024-01-01 12:00:00")
def test_check_deadlines_no_approaching_deadlines():
    """Test checking deadlines when no tasks have approaching deadlines."""
    repo = InMemoryTaskRepository()
    notifications = NotificationRecorder()
    use_case = CheckDeadlinesUseCase(repo, notifications)

    # Create tasks with deadlines well in the future
    far_future_date = datetime.now() + timedelta(days=10)
    task1 = Task(
        title="Future Task 1",
        description="Test",
        due_date=Deadline(far_future_date),
    )
    task2 = Task(
        title="Future Task 2",
        description="Test",
        due_date=Deadline(far_future_date + timedelta(days=1)),
    )

    repo.save(task1)
    repo.save(task2)

    result = use_case.execute()

    assert result.is_success
    assert result.value["notifications_sent"] == 0
    assert not notifications.deadline_warnings


@freeze_time("2024-01-01 12:00:00")
def test_check_deadlines_approaching_deadlines():
    """Test checking deadlines with tasks approaching their deadlines."""
    repo = InMemoryTaskRepository()
    notifications = NotificationRecorder()
    use_case = CheckDeadlinesUseCase(repo, notifications)

    # Create tasks with various deadlines
    approaching_date = datetime.now() + timedelta(hours=23)  # Within 1 day
    future_date = datetime.now() + timedelta(days=5)  # Not approaching

    task1 = Task(
        title="Approaching Task",
        description="Test",
        due_date=Deadline(approaching_date),
    )
    task2 = Task(
        title="Future Task", description="Test", due_date=Deadline(future_date)
    )

    repo.save(task1)
    repo.save(task2)

    result = use_case.execute()

    assert result.is_success
    assert result.value["notifications_sent"] == 1
    assert len(notifications.deadline_warnings) == 1
    assert (
        notifications.deadline_warnings[0][0] == task1.id
    )  # First task should be warned
    assert (
        notifications.deadline_warnings[0][1] == 0
    )  # Less than 1 day remaining


@freeze_time("2024-01-01 12:00:00")
def test_check_deadlines_custom_threshold():
    """Test checking deadlines with a custom warning threshold."""
    repo = InMemoryTaskRepository()
    notifications = NotificationRecorder()
    use_case = CheckDeadlinesUseCase(
        repo, notifications, warning_threshold=timedelta(days=3)
    )

    # Create tasks with various deadlines
    two_days = Task(
        title="Two Days Task",
        description="Test",
        due_date=Deadline(datetime.now() + timedelta(days=2)),
    )
    four_days = Task(
        title="Four Days Task",
        description="Test",
        due_date=Deadline(datetime.now() + timedelta(days=4)),
    )

    repo.save(two_days)
    repo.save(four_days)

    result = use_case.execute()

    assert result.is_success
    assert result.value["notifications_sent"] == 1
    assert len(notifications.deadline_warnings) == 1
    assert notifications.deadline_warnings[0][0] == two_days.id
    assert notifications.deadline_warnings[0][1] == 2  # 2 days remaining


@freeze_time("2024-01-01 12:00:00")
def test_check_deadlines_completed_tasks():
    """Test that completed tasks are not checked for deadlines."""
    repo = InMemoryTaskRepository()
    notifications = NotificationRecorder()
    use_case = CheckDeadlinesUseCase(repo, notifications)

    # Create a completed task with an approaching deadline
    approaching_date = datetime.now() + timedelta(hours=12)
    task = Task(
        title="Completed Task",
        description="Test",
        due_date=Deadline(approaching_date),
    )
    task.complete()  # Mark as complete
    repo.save(task)

    result = use_case.execute()

    assert result.is_success
    assert result.value["notifications_sent"] == 0
    assert not notifications.deadline_warnings


@freeze_time("2024-01-01 12:00:00")
def test_check_deadlines_multiple_notifications():
    """Test checking multiple tasks with approaching deadlines."""
    repo = InMemoryTaskRepository()
    notifications = NotificationRecorder()
    use_case = CheckDeadlinesUseCase(repo, notifications)

    # Create multiple tasks with approaching deadlines
    base_time = datetime.now()
    tasks = []
    for hours in [12, 18, 22]:  # All within 24 hours
        task = Task(
            title=f"Task due in {hours} hours",
            description="Test",
            due_date=Deadline(base_time + timedelta(hours=hours)),
        )
        tasks.append(task)
        repo.save(task)

    result = use_case.execute()

    assert result.is_success
    assert result.value["notifications_sent"] == 3
    assert len(notifications.deadline_warnings) == 3
    # Verify each task got a warning
    task_ids = {warning[0] for warning in notifications.deadline_warnings}
    assert task_ids == {task.id for task in tasks}


@freeze_time("2024-01-01 12:00:00")
def test_check_deadlines_handles_repository_errors():
    """Test handling of repository errors during deadline check."""

    class ErroringTaskRepository(InMemoryTaskRepository):
        def get_active_tasks(self):
            raise BusinessRuleViolation("Repository error")

    repo = ErroringTaskRepository()
    notifications = NotificationRecorder()
    use_case = CheckDeadlinesUseCase(repo, notifications)

    result = use_case.execute()

    assert not result.is_success
    assert result.error.code == ErrorCode.BUSINESS_RULE_VIOLATION
    assert "Repository error" in result.error.message
    assert (
        not notifications.deadline_warnings
    )  # No notifications should be sent


@freeze_time("2024-01-01 12:00:00")
def test_check_deadlines_handles_notification_errors():
    """Test handling of notification service errors."""

    class ErroringNotificationService(NotificationRecorder):
        def notify_task_deadline_approaching(self, task_id, days_remaining):
            raise ValidationError("Notification error")

    repo = InMemoryTaskRepository()
    notifications = ErroringNotificationService()
    use_case = CheckDeadlinesUseCase(repo, notifications)

    # Create a task with approaching deadline
    due_date = datetime.now() + timedelta(hours=12)
    task = Task(
        title="Test Task", description="Test", due_date=Deadline(due_date)
    )
    repo.save(task)

    result = use_case.execute()

    assert not result.is_success
    assert result.error.code == ErrorCode.VALIDATION_ERROR
    assert "Notification error" in result.error.message


@freeze_time("2024-01-01 12:00:00")
def test_check_deadlines_handles_task_not_found():
    """Test handling of TaskNotFoundError during deadline check."""

    class TaskNotFoundRepository(InMemoryTaskRepository):
        def get_active_tasks(self):
            raise TaskNotFoundError(
                UUID("123e4567-e89b-12d3-a456-426614174000")
            )

    repo = TaskNotFoundRepository()
    notifications = NotificationRecorder()
    use_case = CheckDeadlinesUseCase(repo, notifications)

    result = use_case.execute()

    assert not result.is_success
    assert result.error.code == ErrorCode.NOT_FOUND
    assert "Task" in result.error.message
    assert not notifications.deadline_warnings

<file_end>todo_app/tests/application/test_deadline_use_case.py</file_end>

<file_start>todo_app/tests/application/test_project_repo.py</file_start>
from uuid import UUID

import pytest

from todo_app.domain.entities.project import Project
from todo_app.domain.exceptions import ProjectNotFoundError
from todo_app.application.conftest import (
    InMemoryProjectRepository,
)


def test_project_repository_delete():
    """Test deleting a project from repository."""
    repo = InMemoryProjectRepository()
    project = Project(name="Test Project")
    repo.save(project)

    # Verify project exists
    assert repo.get(project.id) == project

    # Delete project
    repo.delete(project.id)

    # Verify project is gone
    with pytest.raises(ProjectNotFoundError):
        repo.get(project.id)


def test_project_repository_delete_nonexistent():
    """Test deleting a nonexistent project."""
    repo = InMemoryProjectRepository()
    random_id = UUID("123e4567-e89b-12d3-a456-426614174000")

    # Should not raise an error when deleting nonexistent project
    repo.delete(random_id)


def test_project_repository_delete_and_recreate():
    """Test deleting a project and then creating a new one with the same name."""
    repo = InMemoryProjectRepository()

    # Create and delete first project
    project1 = Project(name="Test Project")
    repo.save(project1)
    repo.delete(project1.id)

    # Create second project with same name
    project2 = Project(name="Test Project")
    repo.save(project2)

    # Verify new project exists and has different ID
    saved_project = repo.get(project2.id)
    assert saved_project == project2
    assert saved_project.id != project1.id

<file_end>todo_app/tests/application/test_project_repo.py</file_end>

<file_start>todo_app/tests/application/test_task_use_cases.py</file_start>
# todo_app/tests/application/test_task_use_cases.py
"""Tests for task-related use cases."""

from uuid import uuid4

import pytest

from todo_app.application.common.result import ErrorCode
from todo_app.application.dtos.task_dtos import (
    CreateTaskRequest,
    CompleteTaskRequest,
    SetTaskPriorityRequest,
)
from todo_app.application.use_cases.task_use_cases import (
    CreateTaskUseCase,
    CompleteTaskUseCase,
    SetTaskPriorityUseCase,
)
from todo_app.domain.entities.project import Project
from todo_app.domain.entities.task import Task
from todo_app.domain.exceptions import (
    BusinessRuleViolation,
    ValidationError,
)
from todo_app.domain.value_objects import Priority, TaskStatus
from todo_app.application.conftest import (
    InMemoryTaskRepository,
    InMemoryProjectRepository,
    NotificationRecorder,
)


def test_create_task_basic():
    """Test creating a task with basic information."""
    # Arrange
    repo = InMemoryTaskRepository()
    project_repo = InMemoryProjectRepository()
    use_case = CreateTaskUseCase(repo, project_repo)

    request = CreateTaskRequest(
        title="Test Task", description="Test Description"
    )

    # Act
    result = use_case.execute(request)

    # Assert
    assert result.is_success
    assert result.value.title == "Test Task"
    assert result.value.description == "Test Description"
    assert result.value.status == TaskStatus.TODO.value
    assert result.value.priority == Priority.MEDIUM.value


def test_create_task_with_project():
    """Test creating a task associated with a project."""
    # Arrange
    task_repo = InMemoryTaskRepository()
    project_repo = InMemoryProjectRepository()
    use_case = CreateTaskUseCase(task_repo, project_repo)

    # Create a project first
    project = Project(name="Test Project")
    project_repo.save(project)

    request = CreateTaskRequest(
        title="Test Task",
        description="Test Description",
        project_id=str(project.id),
    )

    # Act
    result = use_case.execute(request)

    # Assert
    assert result.is_success
    assert result.value.project_id == str(project.id)


def test_create_task_with_invalid_project():
    """Test creating a task with non-existent project ID."""
    # Arrange
    task_repo = InMemoryTaskRepository()
    project_repo = InMemoryProjectRepository()
    use_case = CreateTaskUseCase(task_repo, project_repo)

    request = CreateTaskRequest(
        title="Test Task",
        description="Test Description",
        project_id=str(uuid4()),
    )

    # Act
    result = use_case.execute(request)

    # Assert
    assert not result.is_success
    assert result.error.code.value == "NOT_FOUND"


def test_complete_task():
    """Test completing a task."""
    # Arrange
    repo = InMemoryTaskRepository()
    notifications = NotificationRecorder()
    use_case = CompleteTaskUseCase(repo, notifications)

    # Create and save a task
    task = Task(title="Test Task", description="Test Description")
    repo.save(task)

    request = CompleteTaskRequest(
        task_id=str(task.id), completion_notes="Done!"
    )

    # Act
    result = use_case.execute(request)

    # Assert
    assert result.is_success
    assert result.value.status == TaskStatus.DONE.value
    assert result.value.completion_notes == "Done!"
    assert task.id in notifications.completed_tasks


def test_complete_nonexistent_task():
    """Test completing a task that doesn't exist."""
    # Arrange
    repo = InMemoryTaskRepository()
    notifications = NotificationRecorder()
    use_case = CompleteTaskUseCase(repo, notifications)

    request = CompleteTaskRequest(
        task_id=str(uuid4()), completion_notes="Done!"
    )

    # Act
    result = use_case.execute(request)

    # Assert
    assert not result.is_success
    assert result.error.code.value == "NOT_FOUND"
    assert not notifications.completed_tasks  # No notification sent


def test_set_task_priority():
    """Test setting a task's priority."""
    # Arrange
    repo = InMemoryTaskRepository()
    notifications = NotificationRecorder()
    use_case = SetTaskPriorityUseCase(repo, notifications)

    # Create and save a task
    task = Task(title="Test Task", description="Test Description")
    repo.save(task)

    request = SetTaskPriorityRequest(task_id=str(task.id), priority="HIGH")

    # Act
    result = use_case.execute(request)

    # Assert
    assert result.is_success
    assert result.value.priority == Priority.HIGH.value
    assert task.id in notifications.high_priority_tasks


def test_set_task_invalid_priority():
    """Test setting an invalid priority."""
    # Arrange
    repo = InMemoryTaskRepository()
    notifications = NotificationRecorder()
    use_case = SetTaskPriorityUseCase(repo, notifications)

    task = Task(title="Test Task", description="Test Description")
    repo.save(task)

    with pytest.raises(ValueError) as exc_info:
        SetTaskPriorityRequest(task_id=str(task.id), priority="INVALID")

    assert "Priority must be one of" in str(exc_info.value)


def test_complete_task_handles_validation_error():
    """Test handling of ValidationError during task completion."""
    task = Task(title="Test Task", description="Test Description")

    class ValidationErrorTaskRepository(InMemoryTaskRepository):
        def save(self, task):
            raise ValidationError("Invalid completion state")

    repo = ValidationErrorTaskRepository()
    repo._tasks[task.id] = task  # Add task directly to repo
    notifications = NotificationRecorder()
    use_case = CompleteTaskUseCase(repo, notifications)

    request = CompleteTaskRequest(
        task_id=str(task.id), completion_notes="Done!"
    )

    result = use_case.execute(request)

    assert not result.is_success
    assert result.error.code == ErrorCode.VALIDATION_ERROR
    assert "Invalid completion state" in result.error.message
    assert not notifications.completed_tasks


def test_complete_task_handles_business_rule_violation():
    """Test handling of BusinessRuleViolation during task completion."""
    task = Task(title="Test Task", description="Test Description")

    class BusinessRuleTaskRepository(InMemoryTaskRepository):
        def save(self, task):
            raise BusinessRuleViolation("Cannot complete task in current state")

    repo = BusinessRuleTaskRepository()
    repo._tasks[task.id] = task  # Add task directly to repo
    notifications = NotificationRecorder()
    use_case = CompleteTaskUseCase(repo, notifications)

    request = CompleteTaskRequest(
        task_id=str(task.id), completion_notes="Done!"
    )

    result = use_case.execute(request)

    assert not result.is_success
    assert result.error.code == ErrorCode.BUSINESS_RULE_VIOLATION
    assert "Cannot complete task in current state" in result.error.message
    assert not notifications.completed_tasks


def test_create_task_request_validates_project_id_format():
    """Test that CreateTaskRequest validates project ID format."""
    # Valid UUID should work
    valid_request = CreateTaskRequest(
        title="Test Task",
        description="Test Description",
        project_id="123e4567-e89b-12d3-a456-426614174000",
    )
    assert valid_request.project_id == "123e4567-e89b-12d3-a456-426614174000"

    # Invalid UUID should raise ValueError
    with pytest.raises(ValueError, match="Invalid project ID format"):
        CreateTaskRequest(
            title="Test Task",
            description="Test Description",
            project_id="not-a-uuid",
        )

    # Empty project_id should be allowed (Optional)
    no_project_request = CreateTaskRequest(
        title="Test Task", description="Test Description", project_id=None
    )
    assert no_project_request.project_id is None


def test_create_task_handles_validation_error():
    """Test handling of ValidationError during task creation."""

    class ValidationErrorTaskRepository(InMemoryTaskRepository):
        def save(self, task):
            raise ValidationError("Invalid task data")

    task_repo = ValidationErrorTaskRepository()
    project_repo = InMemoryProjectRepository()
    use_case = CreateTaskUseCase(task_repo, project_repo)

    request = CreateTaskRequest(
        title="Test Task", description="Test Description"
    )

    result = use_case.execute(request)

    assert not result.is_success
    assert result.error.code == ErrorCode.VALIDATION_ERROR
    assert "Invalid task data" in result.error.message


def test_create_task_handles_business_rule_violation():
    """Test handling of BusinessRuleViolation during task creation."""

    class BusinessRuleTaskRepository(InMemoryTaskRepository):
        def save(self, task):
            raise BusinessRuleViolation("Task limit exceeded")

    task_repo = BusinessRuleTaskRepository()
    project_repo = InMemoryProjectRepository()
    use_case = CreateTaskUseCase(task_repo, project_repo)

    request = CreateTaskRequest(
        title="Test Task", description="Test Description"
    )

    result = use_case.execute(request)

    assert not result.is_success
    assert result.error.code == ErrorCode.BUSINESS_RULE_VIOLATION
    assert "Task limit exceeded" in result.error.message


def test_create_task_handles_validation_error_with_project():
    """Test handling of ValidationError during task creation with project."""
    project = Project(name="Test Project")

    class ValidationErrorTaskRepository(InMemoryTaskRepository):
        def save(self, task):
            raise ValidationError("Invalid task data")

    task_repo = ValidationErrorTaskRepository()
    project_repo = InMemoryProjectRepository()
    project_repo._projects[project.id] = project  # Add project directly
    use_case = CreateTaskUseCase(task_repo, project_repo)

    request = CreateTaskRequest(
        title="Test Task",
        description="Test Description",
        project_id=str(project.id),
    )

    result = use_case.execute(request)

    assert not result.is_success
    assert result.error.code == ErrorCode.VALIDATION_ERROR
    assert "Invalid task data" in result.error.message


def test_complete_task_rolls_back_on_validation_error():
    """Test that task state is rolled back on ValidationError."""
    # Set up task
    task = Task(title="Test Task", description="Test Description")

    class FailingTaskRepository(InMemoryTaskRepository):
        def save(self, task):
            if task.status == TaskStatus.DONE:
                raise ValidationError("Cannot complete task")
            super().save(task)

    repo = FailingTaskRepository()
    notifications = NotificationRecorder()

    # Save initial state
    repo.save(task)

    use_case = CompleteTaskUseCase(repo, notifications)
    request = CompleteTaskRequest(
        task_id=str(task.id), completion_notes="Done!"
    )

    # Execute use case (should fail)
    result = use_case.execute(request)

    # Verify failure
    assert not result.is_success
    assert result.error.code == ErrorCode.VALIDATION_ERROR

    # Verify task state was rolled back
    saved_task = repo.get(task.id)
    assert saved_task.status == TaskStatus.TODO
    assert saved_task.completed_at is None
    assert saved_task.completion_notes is None

    # Verify no notifications were sent
    assert not notifications.completed_tasks


def test_complete_task_rolls_back_on_business_rule_violation():
    """Test that task state is rolled back on BusinessRuleViolation."""
    # Set up task
    task = Task(title="Test Task", description="Test Description")

    class FailingTaskRepository(InMemoryTaskRepository):
        def save(self, task):
            if task.status == TaskStatus.DONE:
                raise BusinessRuleViolation("Task completion limit reached")
            super().save(task)

    repo = FailingTaskRepository()
    notifications = NotificationRecorder()

    # Save initial state
    repo.save(task)

    use_case = CompleteTaskUseCase(repo, notifications)
    request = CompleteTaskRequest(
        task_id=str(task.id), completion_notes="Done!"
    )

    # Execute use case (should fail)
    result = use_case.execute(request)

    # Verify failure
    assert not result.is_success
    assert result.error.code == ErrorCode.BUSINESS_RULE_VIOLATION

    # Verify task state was rolled back
    saved_task = repo.get(task.id)
    assert saved_task.status == TaskStatus.TODO
    assert saved_task.completed_at is None
    assert saved_task.completion_notes is None

    # Verify no notifications were sent
    assert not notifications.completed_tasks


def test_complete_task_maintains_state_on_successful_completion():
    """Test that task state changes persist when completion is successful."""
    task = Task(title="Test Task", description="Test Description")

    repo = InMemoryTaskRepository()
    notifications = NotificationRecorder()

    # Save initial state
    repo.save(task)

    use_case = CompleteTaskUseCase(repo, notifications)
    completion_notes = "Done!"
    request = CompleteTaskRequest(
        task_id=str(task.id), completion_notes=completion_notes
    )

    # Execute use case (should succeed)
    result = use_case.execute(request)

    # Verify success
    assert result.is_success

    # Verify task state was updated and persisted
    saved_task = repo.get(task.id)
    assert saved_task.status == TaskStatus.DONE
    assert saved_task.completed_at is not None
    assert saved_task.completion_notes == completion_notes

    # Verify notification was sent
    assert task.id in notifications.completed_tasks


def test_create_task_with_nonexistent_project():
    """Test handling of nonexistent project ID during task creation."""
    task_repo = InMemoryTaskRepository()
    project_repo = InMemoryProjectRepository()
    use_case = CreateTaskUseCase(task_repo, project_repo)

    # Use a valid UUID format but for a nonexistent project
    request = CreateTaskRequest(
        title="Test Task",
        description="Test Description",
        project_id="123e4567-e89b-12d3-a456-426614174000",  # Valid UUID that doesn't exist
    )

    result = use_case.execute(request)

    assert not result.is_success
    assert result.error.code == ErrorCode.NOT_FOUND
    assert (
        "Project with id 123e4567-e89b-12d3-a456-426614174000 not found"
        in result.error.message
    )


def test_create_task_fails_with_malformed_project_id():
    # Test that this raised ValueError
    with pytest.raises(ValueError, match="Invalid project ID format"):
        _ = CreateTaskRequest(
            title="Test Task",
            description="Test Description",
            project_id="malformed project id",
        )


def test_set_task_priority_fails_with_malformed_task_id():
    # Test that this raised ValueError
    with pytest.raises(ValueError, match="Invalid task ID format"):
        _ = SetTaskPriorityRequest(
            task_id="malformed project id",
            priority="HIGH",
        )


def test_set_task_priority_handles_validation_error():
    """Test handling of ValidationError during priority setting."""
    # Create a task
    task = Task(title="Test Task", description="Test Description")

    class ValidationErrorTaskRepository(InMemoryTaskRepository):
        def save(self, task):
            raise ValidationError("Invalid priority state")

    repo = ValidationErrorTaskRepository()
    repo._tasks[task.id] = task  # Add task directly to repo
    notifications = NotificationRecorder()

    use_case = SetTaskPriorityUseCase(repo, notifications)
    request = SetTaskPriorityRequest(task_id=str(task.id), priority="HIGH")

    result = use_case.execute(request)

    assert not result.is_success
    assert result.error.code == ErrorCode.VALIDATION_ERROR
    assert "Invalid priority state" in result.error.message
    assert not notifications.high_priority_tasks

<file_end>todo_app/tests/application/test_task_use_cases.py</file_end>

<file_start>todo_app/tests/domain/.pytest_cache/CACHEDIR.TAG</file_start>
Signature: 8a477f597d28d172789f06886806bc55
# This file is a cache directory tag created by pytest.
# For information about cache directory tags, see:
#	https://bford.info/cachedir/spec.html

<file_end>todo_app/tests/domain/.pytest_cache/CACHEDIR.TAG</file_end>

<file_start>todo_app/tests/domain/.pytest_cache/README.md</file_start>
# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.

<file_end>todo_app/tests/domain/.pytest_cache/README.md</file_end>

<file_start>todo_app/tests/domain/.pytest_cache/.gitignore</file_start>
# Created by pytest automatically.
*

<file_end>todo_app/tests/domain/.pytest_cache/.gitignore</file_end>

<file_start>todo_app/tests/domain/.pytest_cache/v/cache/nodeids</file_start>
[
  "test_priority_and_deadline.py::TestTaskPriorityCalculator::test_calculate_priority_no_deadline"
]
<file_end>todo_app/tests/domain/.pytest_cache/v/cache/nodeids</file_end>

<file_start>todo_app/tests/domain/.pytest_cache/v/cache/lastfailed</file_start>
{
  "test_priority_and_deadline.py::TestTaskPriorityCalculator::test_calculate_priority_no_deadline": true
}
<file_end>todo_app/tests/domain/.pytest_cache/v/cache/lastfailed</file_end>

<file_start>todo_app/tests/domain/.pytest_cache/v/cache/stepwise</file_start>
[]
<file_end>todo_app/tests/domain/.pytest_cache/v/cache/stepwise</file_end>

<file_start>todo_app/tests/domain/test_active_tasks.py</file_start>
from todo_app.domain.entities.task import Task
from todo_app.domain.value_objects import TaskStatus
from todo_app.application.conftest import (
    InMemoryTaskRepository,
)


def test_get_active_tasks_empty_repository():
    """Test getting active tasks from an empty repository."""
    repo = InMemoryTaskRepository()
    tasks = repo.get_active_tasks()
    assert len(tasks) == 0


def test_get_active_tasks_only_active():
    """Test getting active tasks when all tasks are active."""
    repo = InMemoryTaskRepository()

    # Create and save three active tasks
    task1 = Task(title="Task 1", description="Test")
    task2 = Task(title="Task 2", description="Test")
    task3 = Task(title="Task 3", description="Test")

    repo.save(task1)
    repo.save(task2)
    repo.save(task3)

    tasks = repo.get_active_tasks()
    assert len(tasks) == 3
    assert all(task.status == TaskStatus.TODO for task in tasks)


def test_get_active_tasks_mixed_status():
    """Test getting active tasks with a mix of active and completed tasks."""
    repo = InMemoryTaskRepository()

    # Create and save tasks with different statuses
    todo_task = Task(title="Todo Task", description="Test")
    in_progress_task = Task(title="In Progress Task", description="Test")
    in_progress_task.start()  # Sets status to IN_PROGRESS
    completed_task = Task(title="Completed Task", description="Test")
    completed_task.complete()  # Sets status to DONE

    repo.save(todo_task)
    repo.save(in_progress_task)
    repo.save(completed_task)

    tasks = repo.get_active_tasks()
    assert len(tasks) == 2  # Should only get TODO and IN_PROGRESS tasks
    assert completed_task not in tasks
    assert all(task.status != TaskStatus.DONE for task in tasks)


def test_get_active_tasks_only_completed():
    """Test getting active tasks when all tasks are completed."""
    repo = InMemoryTaskRepository()

    # Create and save three completed tasks
    task1 = Task(title="Task 1", description="Test")
    task2 = Task(title="Task 2", description="Test")
    task3 = Task(title="Task 3", description="Test")

    for task in [task1, task2, task3]:
        task.complete()
        repo.save(task)

    tasks = repo.get_active_tasks()
    assert len(tasks) == 0


def test_get_active_tasks_after_completion():
    """Test getting active tasks after completing some tasks."""
    repo = InMemoryTaskRepository()

    # Create and save initial tasks
    task1 = Task(title="Task 1", description="Test")
    task2 = Task(title="Task 2", description="Test")
    task3 = Task(title="Task 3", description="Test")

    repo.save(task1)
    repo.save(task2)
    repo.save(task3)

    # Initially should have all tasks
    assert len(repo.get_active_tasks()) == 3

    # Complete two tasks
    task1.complete()
    task3.complete()
    repo.save(task1)
    repo.save(task3)

    # Should now only have one active task
    active_tasks = repo.get_active_tasks()
    assert len(active_tasks) == 1
    assert task2 in active_tasks

<file_end>todo_app/tests/domain/test_active_tasks.py</file_end>

<file_start>todo_app/tests/domain/test_priority_and_deadline.py</file_start>
# todo_app/tests/domain/test_priority_and_deadline.py
"""Tests for task priority calculation and deadline value object."""

from datetime import datetime, timedelta

import pytest
from freezegun import freeze_time

from todo_app.domain.entities.task import Task
from todo_app.domain.services.task_priority_calculator import (
    TaskPriorityCalculator,
)
from todo_app.domain.value_objects import Deadline, Priority


class TestDeadline:
    def test_create_valid_future_deadline(self):
        """Test creating a deadline in the future."""
        future_date = datetime.now() + timedelta(days=1)
        deadline = Deadline(future_date)
        assert deadline.due_date == future_date

    def test_reject_past_deadline(self):
        """Test that creating a deadline in the past raises an error."""
        past_date = datetime.now() - timedelta(days=1)
        with pytest.raises(ValueError, match="Deadline cannot be in the past"):
            Deadline(past_date)

    @freeze_time("2024-01-01 12:00:00")
    def test_is_overdue(self):
        """Test checking if a deadline is overdue."""
        # Create a deadline for 1 day from now
        future_date = datetime.now() + timedelta(days=1)
        deadline = Deadline(future_date)
        assert not deadline.is_overdue()

        # Time travel to after the deadline
        with freeze_time("2024-01-03 12:00:00"):
            assert deadline.is_overdue()

    @freeze_time("2024-01-01 12:00:00")
    def test_time_remaining(self):
        """Test calculating remaining time until deadline."""
        # Create a deadline for exactly 2 days from now
        due_date = datetime.now() + timedelta(days=2)
        deadline = Deadline(due_date)

        remaining = deadline.time_remaining()
        assert remaining == timedelta(days=2)

        # Time travel to 1 day before deadline
        with freeze_time("2024-01-02 12:00:00"):
            remaining = deadline.time_remaining()
            assert remaining == timedelta(days=1)

        # Time travel past deadline
        with freeze_time("2024-01-04 12:00:00"):
            remaining = deadline.time_remaining()
            assert remaining == timedelta(0)  # Should return 0 when overdue

    @freeze_time("2024-01-01 12:00:00")
    def test_is_approaching(self):
        """Test detecting when deadline is approaching."""
        # Create deadlines at various distances
        far_date = datetime.now() + timedelta(days=5)
        near_date = datetime.now() + timedelta(hours=12)
        very_near_date = datetime.now() + timedelta(hours=1)

        far_deadline = Deadline(far_date)
        near_deadline = Deadline(near_date)
        very_near_deadline = Deadline(very_near_date)

        # Test with default 1-day warning threshold
        assert not far_deadline.is_approaching()
        assert near_deadline.is_approaching()
        assert very_near_deadline.is_approaching()

        # Test with custom warning threshold
        custom_threshold = timedelta(hours=2)
        assert not near_deadline.is_approaching(custom_threshold)
        assert very_near_deadline.is_approaching(custom_threshold)


class TestTaskPriorityCalculator:
    @freeze_time("2024-01-01 12:00:00")
    def test_calculate_priority_overdue(self):
        """Test priority calculation for overdue tasks."""
        # Create a task that will be overdue
        due_date = datetime.now() + timedelta(days=1)
        task = Task(
            title="Test Task",
            description="Test Description",
            due_date=Deadline(due_date),
        )

        # Time travel to after the deadline
        with freeze_time("2024-01-03 12:00:00"):
            priority = TaskPriorityCalculator.calculate_priority(task)
            assert priority == Priority.HIGH

    @freeze_time("2024-01-01 12:00:00")
    def test_calculate_priority_approaching_deadline(self):
        """Test priority calculation for tasks with approaching deadlines."""
        # Create a task due in 2 days
        due_date = datetime.now() + timedelta(days=2)
        task = Task(
            title="Test Task",
            description="Test Description",
            due_date=Deadline(due_date),
        )

        priority = TaskPriorityCalculator.calculate_priority(task)
        assert priority == Priority.MEDIUM

    @freeze_time("2024-01-01 12:00:00")
    def test_calculate_priority_far_deadline(self):
        """Test priority calculation for tasks with far deadlines."""
        # Create a task due in 5 days
        due_date = datetime.now() + timedelta(days=5)
        task = Task(
            title="Test Task",
            description="Test Description",
            due_date=Deadline(due_date),
        )

        priority = TaskPriorityCalculator.calculate_priority(task)
        assert priority == Priority.LOW

    def test_calculate_priority_no_deadline(self):
        """Test priority calculation for tasks without deadlines."""
        task = Task(title="Test Task", description="Test Description")
        expected_priority = task.priority
        priority = TaskPriorityCalculator.calculate_priority(task)
        assert priority == expected_priority

    @pytest.mark.parametrize(
        "days_until_due,expected_priority",
        [
            (0.5, Priority.HIGH),  # 12 hours until due
            (1, Priority.MEDIUM),  # 1 day until due
            (2, Priority.MEDIUM),  # 2 days until due
            (3, Priority.LOW),  # 3 days until due
            (7, Priority.LOW),  # 1 week until due
        ],
    )
    @freeze_time("2024-01-01 12:00:00")
    def test_priority_thresholds(self, days_until_due, expected_priority):
        """Test various deadline thresholds and their resulting priorities."""
        due_date = datetime.now() + timedelta(days=days_until_due)
        task = Task(
            title="Test Task",
            description="Test Description",
            due_date=Deadline(due_date),
        )
        priority = TaskPriorityCalculator.calculate_priority(task)
        assert priority == expected_priority

<file_end>todo_app/tests/domain/test_priority_and_deadline.py</file_end>

<file_start>todo_app/application/repositories/project_repository.py</file_start>
"""
This module defines the repository interface for Project entity persistence.
"""

from abc import ABC, abstractmethod
from uuid import UUID

from todo_app.domain.entities.project import Project


class ProjectRepository(ABC):
    """Repository interface for Project entity persistence."""

    @abstractmethod
    def get(self, project_id: UUID) -> Project:
        """
        Retrieve a project by its ID.

        Args:
            project_id: The unique identifier of the project

        Returns:
            The requested Project entity

        Raises:
            ProjectNotFoundError: If no project exists with the given ID
        """
        pass

    @abstractmethod
    def save(self, project: Project) -> None:
        """
        Save a project to the repository.

        Args:
            project: The Project entity to save
        """
        pass

    @abstractmethod
    def delete(self, project_id: UUID) -> None:
        """
        Delete a project from the repository.

        Args:
            project_id: The unique identifier of the project to delete
        """
        pass

<file_end>todo_app/application/repositories/project_repository.py</file_end>

<file_start>todo_app/application/repositories/task_repository.py</file_start>
"""
This module defines the repository interface for Task entity persistence.
"""

from abc import ABC, abstractmethod
from typing import Sequence
from uuid import UUID

from todo_app.domain.entities.task import Task


class TaskRepository(ABC):
    """Repository interface for Task entity persistence."""

    @abstractmethod
    def get(self, task_id: UUID) -> Task:
        """
        Retrieve a task by its ID.

        Args:
            task_id: The unique identifier of the task

        Returns:
            The requested Task entity

        Raises:
            TaskNotFoundError: If no task exists with the given ID
        """
        pass

    @abstractmethod
    def save(self, task: Task) -> None:
        """
        Save a task to the repository.

        Args:
            task: The Task entity to save
        """
        pass

    @abstractmethod
    def delete(self, task_id: UUID) -> None:
        """
        Delete a task from the repository.

        Args:
            task_id: The unique identifier of the task to delete
        """
        pass

    @abstractmethod
    def find_by_project(self, project_id: UUID) -> Sequence[Task]:
        """
        Find all tasks associated with a project.

        Args:
            project_id: The unique identifier of the project

        Returns:
            A sequence of Task entities belonging to the project
        """
        pass

    @abstractmethod
    def get_active_tasks(self) -> Sequence[Task]:
        """
        Retrieve all active tasks in the repository.

        Returns:
            A sequence of all active Tasks
        """
        pass

<file_end>todo_app/application/repositories/task_repository.py</file_end>

<file_start>todo_app/application/dtos/task_dtos.py</file_start>
"""
This module contains request and response data transfer objects (DTOs) for task operations.
These DTOs handle data transformation between the outer layers and the application core.
"""

from dataclasses import dataclass
from datetime import datetime
from typing import Optional, Self
from uuid import UUID

from todo_app.domain.entities.task import Task
from todo_app.domain.value_objects import Deadline, Priority


@dataclass(frozen=True)
class CompleteTaskRequest:
    """Request data for completing a task."""

    task_id: str
    completion_notes: Optional[str] = None

    def __post_init__(self) -> None:
        """Validate request data"""
        if not self.task_id.strip():
            raise ValueError("Task ID is required")
        if self.completion_notes and len(self.completion_notes) > 1000:
            raise ValueError("Completion notes cannot exceed 1000 characters")
        try:
            UUID(self.task_id)
        except ValueError:
            raise ValueError("Invalid task ID format")

    def to_execution_params(self) -> dict:
        """Convert request data to use case parameters."""
        return {
            "task_id": UUID(self.task_id),
            "completion_notes": self.completion_notes,
        }


@dataclass(frozen=True)
class CreateTaskRequest:
    """Request data for creating a new task."""

    title: str
    description: str
    due_date: Optional[str] = None
    priority: Optional[str] = None
    project_id: Optional[str] = None

    def __post_init__(self) -> None:
        """Validate request data"""
        if not self.title.strip():
            raise ValueError("Title is required")
        if len(self.title) > 200:
            raise ValueError("Title cannot exceed 200 characters")
        if len(self.description) > 2000:
            raise ValueError("Description cannot exceed 2000 characters")
        if self.project_id:
            try:
                UUID(self.project_id)
            except ValueError:
                raise ValueError("Invalid project ID format")

    def to_execution_params(self) -> dict:
        """Convert request data to use case parameters."""
        params = {
            "title": self.title.strip(),
            "description": self.description.strip(),
        }

        if self.due_date:
            params["deadline"] = Deadline(datetime.fromisoformat(self.due_date))

        if self.priority:
            params["priority"] = Priority[self.priority.upper()]

        if self.project_id:
            params["project_id"] = UUID(self.project_id)

        return params


@dataclass(frozen=True)
class TaskResponse:
    """Response data for task operations."""

    id: str
    title: str
    description: str
    status: str
    priority: str
    due_date: Optional[str] = None
    project_id: Optional[str] = None
    completion_date: Optional[str] = None
    completion_notes: Optional[str] = None

    @classmethod
    def from_entity(cls, task: Task) -> Self:
        """Create response from a Task entity."""
        return cls(
            id=str(task.id),
            title=task.title,
            description=task.description,
            status=task.status.value,
            priority=task.priority.value,
            due_date=(
                task.due_date.due_date.isoformat() if task.due_date else None
            ),
            project_id=str(task.project_id) if task.project_id else None,
            completion_date=(
                task.completed_at.isoformat() if task.completed_at else None
            ),
            completion_notes=task.completion_notes,
        )


@dataclass(frozen=True)
class SetTaskPriorityRequest:
    """Request data for updating task priority."""

    task_id: str
    priority: str

    def __post_init__(self) -> None:
        """Validate request data"""
        if not self.task_id.strip():
            raise ValueError("Task ID is required")

        try:
            priority_value = self.priority.strip().upper()
            if not priority_value:
                raise ValueError
            if priority_value not in [p.name for p in Priority]:
                raise ValueError
        except (AttributeError, ValueError):
            raise ValueError(
                f"Priority must be one of: {', '.join(p.name for p in Priority)}"
            )
        try:
            UUID(self.task_id)
        except ValueError:
            raise ValueError("Invalid task ID format")

    def to_execution_params(self) -> dict:
        """Convert request data to use case parameters."""
        return {
            "task_id": UUID(self.task_id),
            "priority": Priority[self.priority.upper()],
        }

<file_end>todo_app/application/dtos/task_dtos.py</file_end>

<file_start>todo_app/application/dtos/project_dtos.py</file_start>
"""
This module contains request and response data transfer objects (DTOs) for project operations.
These DTOs handle data transformation between the outer layers and the application core.
"""

from dataclasses import dataclass
from typing import Optional, Sequence, Self
from uuid import UUID

from todo_app.application.dtos.task_dtos import TaskResponse
from todo_app.domain.entities.project import Project


@dataclass(frozen=True)
class CreateProjectRequest:
    """Request data for creating a new project."""

    name: str
    description: str = ""

    def __post_init__(self) -> None:
        """Validate request data"""
        if not self.name.strip():
            raise ValueError("Project name is required")
        if len(self.name) > 100:
            raise ValueError("Project name cannot exceed 100 characters")
        if len(self.description) > 2000:
            raise ValueError("Description cannot exceed 2000 characters")

    def to_execution_params(self) -> dict:
        """Convert request data to use case parameters."""
        return {
            "name": self.name.strip(),
            "description": self.description.strip(),
        }


@dataclass(frozen=True)
class CompleteProjectRequest:
    """Request data for completing a project."""

    project_id: str
    completion_notes: Optional[str] = None

    def __post_init__(self) -> None:
        """Validate request data"""
        if not self.project_id.strip():
            raise ValueError("Project ID is required")
        if self.completion_notes and len(self.completion_notes) > 1000:
            raise ValueError("Completion notes cannot exceed 1000 characters")
        try:
            UUID(self.project_id)
        except ValueError:
            raise ValueError("Invalid project ID format")

    def to_execution_params(self) -> dict:
        """Convert request data to use case parameters."""
        return {
            "project_id": UUID(self.project_id),
            "completion_notes": self.completion_notes,
        }


@dataclass(frozen=True)
class ProjectResponse:
    """Response data for basic project operations."""

    id: str
    name: str
    description: str
    status: str
    tasks: Sequence[TaskResponse]

    @classmethod
    def from_entity(cls, project: Project) -> Self:
        """Create response from a Project entity."""
        return cls(
            id=str(project.id),
            name=project.name,
            description=project.description,
            status=project.status.value,
            tasks=[TaskResponse.from_entity(task) for task in project.tasks],
        )


@dataclass(frozen=True)
class CompleteProjectResponse:
    """Response data specific to project completion."""

    id: str
    status: str
    completion_date: str
    task_count: int
    completion_notes: Optional[str]

    @classmethod
    def from_entity(cls, project: Project) -> Self:
        """Create response from a Project entity."""
        return cls(
            id=str(project.id),
            status=project.status.value,
            completion_date=project.completed_at.isoformat(),
            task_count=len(project.tasks),
            completion_notes=project.completion_notes,
        )

<file_end>todo_app/application/dtos/project_dtos.py</file_end>

<file_start>todo_app/application/common/result.py</file_start>
"""
This module contains the core error handling and result types for the application layer.
These types provide a consistent way to handle success and failure cases across all use cases.
"""

from dataclasses import dataclass
from enum import Enum
from typing import Any, Optional, Self


class ErrorCode(Enum):
    """Enumeration of possible error codes in the application layer."""

    NOT_FOUND = "NOT_FOUND"
    VALIDATION_ERROR = "VALIDATION_ERROR"
    BUSINESS_RULE_VIOLATION = "BUSINESS_RULE_VIOLATION"
    UNAUTHORIZED = "UNAUTHORIZED"
    CONFLICT = "CONFLICT"


@dataclass(frozen=True)
class Error:
    """
    Represents an error that occurred during use case execution.

    This class provides a standardized way to represent errors across the application layer,
    including the specific type of error (via ErrorCode) and any additional context.

    Attributes:
        code: The type of error that occurred
        message: A human-readable description of the error
        details: Optional additional context about the error
    """

    code: ErrorCode
    message: str
    details: Optional[dict[str, Any]] = None

    @classmethod
    def not_found(cls, entity: str, entity_id: str) -> Self:
        """Create a NOT_FOUND error for a specific entity."""
        return cls(
            code=ErrorCode.NOT_FOUND,
            message=f"{entity} with id {entity_id} not found",
        )

    @classmethod
    def validation_error(cls, message: str) -> Self:
        """Create a VALIDATION_ERROR with the specified message."""
        return cls(code=ErrorCode.VALIDATION_ERROR, message=message)

    @classmethod
    def business_rule_violation(cls, message: str) -> Self:
        """Create a BUSINESS_RULE_VIOLATION error with the specified message."""
        return cls(code=ErrorCode.BUSINESS_RULE_VIOLATION, message=message)


@dataclass(frozen=True)
class Result:
    """
    Represents the outcome of a use case execution, either success or failure.

    This class provides a way to handle both successful and failed outcomes,
    ensuring that error handling is explicit and consistent across the application layer.

    Attributes:
        value: The success value (if successful)
        error: The error details (if failed)
    """

    value: Any = None
    error: Optional[Error] = None

    @property
    def is_success(self) -> bool:
        """Check if the result represents a successful operation."""
        return self.error is None

    @classmethod
    def success(cls, value: Any) -> Self:
        """Create a successful result with the given value."""
        return cls(value=value)

    @classmethod
    def failure(cls, error: Error) -> Self:
        """Create a failed result with the given error."""
        return cls(error=error)

<file_end>todo_app/application/common/result.py</file_end>

<file_start>todo_app/application/use_cases/task_use_cases.py</file_start>
"""
This module contains use cases for task operations.
"""

from copy import deepcopy
from dataclasses import dataclass

from todo_app.application.common.result import Result, Error
from todo_app.application.dtos.task_dtos import (
    CompleteTaskRequest,
    CreateTaskRequest,
    TaskResponse,
    SetTaskPriorityRequest,
)
from todo_app.application.ports.notifications import (
    NotificationPort,
)
from todo_app.application.repositories.project_repository import (
    ProjectRepository,
)
from todo_app.application.repositories.task_repository import (
    TaskRepository,
)
from todo_app.domain.entities.task import Task
from todo_app.domain.exceptions import (
    TaskNotFoundError,
    ProjectNotFoundError,
    ValidationError,
    BusinessRuleViolation,
)
from todo_app.domain.value_objects import Priority


@dataclass
class CompleteTaskUseCase:
    """Use case for marking a task as complete and notifying stakeholders."""

    task_repository: TaskRepository
    notification_service: NotificationPort

    def execute(self, request: CompleteTaskRequest) -> Result:
        """Execute the use case."""
        try:
            params = request.to_execution_params()
            task = self.task_repository.get(params["task_id"])

            # Take snapshot of initial state
            task_snapshot = deepcopy(task)

            try:
                task.complete(notes=params["completion_notes"])
                self.task_repository.save(task)
                self.notification_service.notify_task_completed(task.id)

                return Result.success(TaskResponse.from_entity(task))

            except (ValidationError, BusinessRuleViolation) as e:
                # Restore task state
                self.task_repository.save(task_snapshot)
                raise  # Re-raise the exception to be caught by outer try block

        except TaskNotFoundError:
            return Result.failure(
                Error.not_found("Task", str(params["task_id"]))
            )
        except ValidationError as e:
            return Result.failure(Error.validation_error(str(e)))
        except BusinessRuleViolation as e:
            return Result.failure(Error.business_rule_violation(str(e)))


@dataclass
class CreateTaskUseCase:
    """Use case for creating a new task."""

    task_repository: TaskRepository
    project_repository: ProjectRepository

    def execute(self, request: CreateTaskRequest) -> Result:
        """Execute the use case."""
        try:
            params = request.to_execution_params()

            # If task is part of a project, verify project exists
            project_id = params.get("project_id")
            if project_id:
                self.project_repository.get(project_id)

            task = Task(
                title=params["title"],
                description=params["description"],
                due_date=params.get("deadline"),
                priority=params.get("priority", Priority.MEDIUM),
            )

            # Set the project_id if one was provided
            if project_id:
                task.project_id = project_id

            self.task_repository.save(task)

            return Result.success(TaskResponse.from_entity(task))

        except ProjectNotFoundError:
            return Result.failure(
                Error.not_found("Project", str(params.get("project_id")))
            )
        except ValidationError as e:
            return Result.failure(Error.validation_error(str(e)))
        except BusinessRuleViolation as e:
            return Result.failure(Error.business_rule_violation(str(e)))


@dataclass
class SetTaskPriorityUseCase:
    task_repository: TaskRepository
    notification_service: NotificationPort  # Depends on capability interface

    def execute(self, request: SetTaskPriorityRequest) -> Result:
        try:
            params = request.to_execution_params()

            task = self.task_repository.get(params["task_id"])
            task.priority = params["priority"]

            self.task_repository.save(task)

            if task.priority == Priority.HIGH:
                self.notification_service.notify_task_high_priority(task.id)

            return Result.success(TaskResponse.from_entity(task))
        except ValidationError as e:
            return Result.failure(Error.validation_error(str(e)))

<file_end>todo_app/application/use_cases/task_use_cases.py</file_end>

<file_start>todo_app/application/use_cases/deadline_use_cases.py</file_start>
from dataclasses import field, dataclass
from datetime import timedelta

from todo_app.application.common.result import Result, Error
from todo_app.application.ports.notifications import (
    NotificationPort,
)
from todo_app.application.repositories.task_repository import (
    TaskRepository,
)
from todo_app.domain.exceptions import (
    TaskNotFoundError,
    ValidationError,
    BusinessRuleViolation,
)


@dataclass
class CheckDeadlinesUseCase:
    """Use case for checking and notifying about approaching task deadlines."""

    task_repository: TaskRepository
    notification_service: NotificationPort
    warning_threshold: timedelta = field(default=timedelta(days=1))

    def execute(self) -> Result:
        """Check all tasks and notify about approaching deadlines."""
        try:
            tasks = self.task_repository.get_active_tasks()
            notifications_sent = 0

            for task in tasks:
                if task.due_date and task.due_date.is_approaching(
                    self.warning_threshold
                ):
                    remaining_days = int(
                        task.due_date.time_remaining().total_seconds()
                        / (24 * 3600)
                    )
                    self.notification_service.notify_task_deadline_approaching(
                        task.id, remaining_days
                    )
                    notifications_sent += 1

            return Result.success({"notifications_sent": notifications_sent})

        except TaskNotFoundError as e:
            return Result.failure(Error.not_found("Task", str(e)))
        except ValidationError as e:
            return Result.failure(Error.validation_error(str(e)))
        except BusinessRuleViolation as e:
            return Result.failure(Error.business_rule_violation(str(e)))

<file_end>todo_app/application/use_cases/deadline_use_cases.py</file_end>

<file_start>todo_app/application/use_cases/project_use_cases.py</file_start>
"""
This module contains use cases for project operations.
"""

from copy import deepcopy
from dataclasses import dataclass

from todo_app.application.common.result import Result, Error
from todo_app.application.dtos.project_dtos import (
    CreateProjectRequest,
    ProjectResponse,
    CompleteProjectRequest,
    CompleteProjectResponse,
)
from todo_app.application.ports.notifications import (
    NotificationPort,
)
from todo_app.application.repositories.project_repository import (
    ProjectRepository,
)
from todo_app.application.repositories.task_repository import (
    TaskRepository,
)
from todo_app.domain.entities.project import Project
from todo_app.domain.exceptions import (
    ValidationError,
    BusinessRuleViolation,
    ProjectNotFoundError,
)


@dataclass
class CreateProjectUseCase:
    """Use case for creating a new project."""

    project_repository: ProjectRepository

    def execute(self, request: CreateProjectRequest) -> Result:
        """Execute the use case."""
        try:
            params = request.to_execution_params()

            project = Project(
                name=params["name"], description=params["description"]
            )

            self.project_repository.save(project)

            return Result.success(ProjectResponse.from_entity(project))

        except ValidationError as e:
            return Result.failure(Error.validation_error(str(e)))
        except BusinessRuleViolation as e:
            return Result.failure(Error.business_rule_violation(str(e)))


@dataclass
class CompleteProjectUseCase:
    """Use case for marking a project as complete."""

    project_repository: ProjectRepository
    task_repository: TaskRepository
    notification_service: NotificationPort

    def execute(self, request: CompleteProjectRequest) -> Result:
        """Execute the use case."""
        try:
            params = request.to_execution_params()
            project = self.project_repository.get(params["project_id"])

            # Take snapshots of initial state
            project_snapshot = deepcopy(project)
            task_snapshots = {
                task.id: deepcopy(task) for task in project.incomplete_tasks
            }

            try:
                # Complete all outstanding tasks
                for task in project.incomplete_tasks:
                    task.complete()
                    self.task_repository.save(task)

                project.mark_completed(
                    notes=params["completion_notes"],
                )

                self.project_repository.save(project)
                for task in project_snapshot.incomplete_tasks:
                    self.notification_service.notify_task_completed(task.id)
                return Result.success(
                    CompleteProjectResponse.from_entity(project)
                )

            except (ValidationError, BusinessRuleViolation) as e:
                # Restore project state
                for task_id, task_snapshot in task_snapshots.items():
                    self.task_repository.save(task_snapshot)
                self.project_repository.save(project_snapshot)
                raise  # Re-raise the exception to be caught by outer try block

        except ProjectNotFoundError:
            return Result.failure(
                Error.not_found("Project", str(params["project_id"]))
            )
        except ValidationError as e:
            return Result.failure(Error.validation_error(str(e)))
        except BusinessRuleViolation as e:
            return Result.failure(Error.business_rule_violation(str(e)))

<file_end>todo_app/application/use_cases/project_use_cases.py</file_end>

<file_start>todo_app/application/ports/notifications.py</file_start>
# todo_app/application/ports/notifications.py
"""
This module defines the notification interface (port) for external notification services.
"""

from abc import ABC, abstractmethod
from uuid import UUID


class NotificationPort(ABC):
    """Interface for sending notifications about task events."""

    @abstractmethod
    def notify_task_completed(self, task_id: UUID) -> None:
        """Notify when a task is completed."""
        pass

    @abstractmethod
    def notify_task_high_priority(self, task_id: UUID) -> None:
        """Notify when a task is set to high priority."""
        pass

    @abstractmethod
    def notify_task_deadline_approaching(
        self, task_id: UUID, days_remaining: int
    ) -> None:
        """Notify when a task's deadline is approaching."""
        pass

<file_end>todo_app/application/ports/notifications.py</file_end>

<file_start>todo_app/domain/value_objects.py</file_start>
"""
This is a judgement call as to placing all these objects in one
file or in their own files.  It's really the developer's preference
"""

from dataclasses import dataclass
from datetime import datetime, timedelta
from enum import Enum


class TaskStatus(Enum):
    TODO = "TODO"
    IN_PROGRESS = "IN_PROGRESS"
    DONE = "DONE"


class ProjectStatus(Enum):
    ACTIVE = "ACTIVE"
    COMPLETED = "COMPLETED"


class Priority(Enum):
    LOW = 1
    MEDIUM = 2
    HIGH = 3


# frozen=True makes this immutable as it should be for a Value Object
@dataclass(frozen=True)
class Deadline:
    due_date: datetime

    def __post_init__(self):
        if self.due_date < datetime.now():
            raise ValueError("Deadline cannot be in the past")

    def is_overdue(self) -> bool:
        return datetime.now() > self.due_date

    def time_remaining(self) -> timedelta:
        return max(timedelta(0), self.due_date - datetime.now())

    def is_approaching(
        self, warning_threshold: timedelta = timedelta(days=1)
    ) -> bool:
        return timedelta(0) < self.time_remaining() <= warning_threshold

<file_end>todo_app/domain/value_objects.py</file_end>

<file_start>todo_app/domain/exceptions.py</file_start>
"""
This module contains domain-specific exceptions for the todo application.
These exceptions represent error conditions specific to the domain model.
"""

from uuid import UUID


class DomainError(Exception):
    """Base class for domain-specific errors."""

    pass


class TaskNotFoundError(DomainError):
    """Raised when attempting to access a task that doesn't exist."""

    def __init__(self, task_id: UUID) -> None:
        self.task_id = task_id
        super().__init__(f"Task with id {task_id} not found")


class ProjectNotFoundError(DomainError):
    """Raised when attempting to access a project that doesn't exist."""

    def __init__(self, project_id: UUID) -> None:
        self.project_id = project_id
        super().__init__(f"Project with id {project_id} not found")


class ValidationError(DomainError):
    """Raised when domain validation rules are violated."""

    pass


class BusinessRuleViolation(DomainError):
    """Raised when a business rule is violated."""

    pass

<file_end>todo_app/domain/exceptions.py</file_end>

<file_start>todo_app/domain/services/task_priority_calculator.py</file_start>
from datetime import timedelta

from todo_app.domain.entities.task import Task
from todo_app.domain.value_objects import Priority


class TaskPriorityCalculator:
    @staticmethod
    def calculate_priority(task: Task) -> Priority:
        """
        Consider Task Priority based on impending due date

        """
        # No adjustment needed if no due date
        if task.due_date is None:
            return task.priority
        # High if overdue or due within 12 hours
        if task.is_overdue() or task.due_date.time_remaining() <= timedelta(
            hours=12
        ):
            return Priority.HIGH
        # Med if task due within 2 days
        elif task.due_date and task.due_date.time_remaining() <= timedelta(
            days=2
        ):
            return Priority.MEDIUM
        else:
            return Priority.LOW

<file_end>todo_app/domain/services/task_priority_calculator.py</file_end>

<file_start>todo_app/domain/entities/task.py</file_start>
from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional
from uuid import UUID

from todo_app.domain.entities.entity import Entity
from todo_app.domain.value_objects import (
    Deadline,
    Priority,
    TaskStatus,
)


@dataclass
class Task(Entity):
    """A task that needs to be completed."""

    title: str
    description: str
    due_date: Optional[Deadline] = None
    priority: Priority = Priority.MEDIUM
    status: TaskStatus = field(default=TaskStatus.TODO, init=False)
    completed_at: Optional[datetime] = field(default=None, init=False)
    completion_notes: Optional[str] = field(default=None, init=False)
    project_id: Optional[UUID] = field(default=None, init=False)

    def start(self) -> None:
        """Mark the task as in progress."""
        if self.status != TaskStatus.TODO:
            raise ValueError("Only tasks with 'TODO' status can be started")
        self.status = TaskStatus.IN_PROGRESS

    def complete(self, notes: Optional[str] = None) -> None:
        """
        Mark the task as complete.

        Args:
            notes: Optional completion notes

        Raises:
            ValueError: If task is already completed
        """
        if self.status == TaskStatus.DONE:
            raise ValueError("Task is already completed")
        self.status = TaskStatus.DONE
        self.completed_at = datetime.now()
        self.completion_notes = notes

    def is_overdue(self) -> bool:
        """Check if the task is overdue."""
        return self.due_date is not None and self.due_date.is_overdue()

<file_end>todo_app/domain/entities/task.py</file_end>

<file_start>todo_app/domain/entities/entity.py</file_start>
from dataclasses import dataclass, field
from uuid import UUID, uuid4


@dataclass
class Entity:
    # Automatically generates a unique UUID for the 'id' field;
    #   excluded from the __init__ method
    id: UUID = field(default_factory=uuid4, init=False)

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return NotImplemented
        return self.id == other.id

    def __hash__(self) -> int:
        return hash(self.id)

<file_end>todo_app/domain/entities/entity.py</file_end>

<file_start>todo_app/domain/entities/project.py</file_start>
from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional
from uuid import UUID

from todo_app.domain.entities.entity import Entity
from todo_app.domain.entities.task import Task
from todo_app.domain.value_objects import (
    TaskStatus,
    ProjectStatus,
)


@dataclass
class Project(Entity):
    """A project containing multiple tasks."""

    name: str
    description: str = ""
    status: ProjectStatus = field(default=ProjectStatus.ACTIVE, init=False)
    completed_at: Optional[datetime] = field(default=None, init=False)
    completion_notes: Optional[str] = field(default=None, init=False)
    _tasks: dict[UUID, Task] = field(default_factory=dict, init=False)

    def add_task(self, task: Task) -> None:
        """Add a task to the project."""
        if self.status == ProjectStatus.COMPLETED:
            raise ValueError("Cannot add tasks to a completed project")
        self._tasks[task.id] = task
        task.project_id = self.id

    def remove_task(self, task_id: UUID) -> None:
        """Remove a task from the project."""
        if task := self._tasks.pop(task_id, None):
            task.project_id = None

    def get_task(self, task_id: UUID) -> Optional[Task]:
        """Get a task by its ID."""
        return self._tasks.get(task_id)

    @property
    def tasks(self) -> list[Task]:
        """Get all tasks in the project."""
        return list(self._tasks.values())

    @property
    def incomplete_tasks(self) -> list[Task]:
        """Get all incomplete tasks in the project."""
        return [task for task in self.tasks if task.status != TaskStatus.DONE]

    def mark_completed(self, notes: Optional[str] = None) -> None:
        """
        Mark the project as completed.

        Args:
            notes: Optional completion notes
        """
        self.status = ProjectStatus.COMPLETED
        self.completed_at = datetime.now()
        self.completion_notes = notes

<file_end>todo_app/domain/entities/project.py</file_end>

